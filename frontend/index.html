<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Socious Translator</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { font-family: 'Inter', 'Helvetica Neue', sans-serif; }
    .caret::after { content: ' ▌'; opacity: 0.6; }
  </style>
</head>
<body class="bg-[#111112] text-white min-h-screen flex flex-col items-center justify-start p-6 space-y-10">

  <h1 class="text-3xl font-bold tracking-tight text-center">Socious Translator</h1>

  <!-- Controls -->
  <div class="w-full max-w-3xl bg-[#1A1A1C] rounded-2xl p-6 shadow-lg flex flex-col items-center space-y-6">
    <div class="w-full flex flex-col lg:flex-row lg:items-end lg:justify-center lg:gap-6 space-y-4 lg:space-y-0">
      <div class="flex flex-col w-full lg:w-auto items-center">
        <label for="direction" class="text-base font-medium mb-1">Translation Direction</label>
        <select id="direction" class="w-full lg:w-64 bg-[#2A2A2E] text-white border border-gray-700 rounded px-4 py-2 focus:outline-none text-center">
          <option value="en-ja">English → Japanese</option>
          <option value="ja-en">Japanese → English</option>
        </select>
      </div>
      <div class="flex flex-col sm:flex-row gap-4">
        <button id="startBtn" class="bg-gray-700 hover:bg-gray-600 text-white font-semibold px-6 py-2 rounded transition-all">Start Recording</button>
        <button id="stopBtn" disabled class="bg-gray-500 text-white font-semibold px-6 py-2 rounded opacity-50 cursor-not-allowed">Stop Recording</button>
      </div>
    </div>
  </div>

  <!-- Output -->
  <div class="w-full max-w-4xl flex flex-col space-y-6 items-center">
    <div class="w-full">
      <div id="output" class="bg-[#1A1A1C] rounded-lg px-6 py-10 shadow-md text-2xl font-semibold leading-8 tracking-wide min-h-[160px] w-full">
        <div id="committed"></div>
      </div>
    </div>
  </div>

  <script>
    const startBtn = document.getElementById("startBtn");
    const stopBtn = document.getElementById("stopBtn");
    const directionSelect = document.getElementById("direction");
    const committed = document.getElementById("committed");

    let mediaStream = null;
    let socket = null;
    let recording = false;
    let activeDiv = null;

    function wsUrl() {
      const proto = location.protocol === "https:" ? "wss" : "ws";
      return `${proto}://${location.host}/ws`;
    }

    directionSelect.onchange = () => stopRecording();

    function setButtons(running) {
      startBtn.disabled = running;
      stopBtn.disabled = !running;
      startBtn.classList.toggle("opacity-50", running);
      startBtn.classList.toggle("cursor-not-allowed", running);
      stopBtn.classList.toggle("opacity-50", !running);
      stopBtn.classList.toggle("cursor-not-allowed", !running);
    }

    function ensureActiveDiv() {
      if (!activeDiv) {
        activeDiv = document.createElement("div");
        activeDiv.className = "text-white caret mb-3";
        activeDiv.style.whiteSpace = "pre-wrap";
        activeDiv.style.lineHeight = "1.6";
        activeDiv.style.wordBreak = "break-word";
        committed.appendChild(activeDiv);
      }
      return activeDiv;
    }

    function setActivePartial(text) {
      const el = ensureActiveDiv();
      el.textContent = text || "";
    }

    function clearActivePartial() {
      if (activeDiv) activeDiv.classList.remove("caret");
    }

    function commitFinal(text) {
      if (!activeDiv) ensureActiveDiv();
      activeDiv.classList.remove("caret");
      activeDiv.textContent = (text || "").trim();
      activeDiv = null;
    }

    function handleMessage(data) {
      try {
        if (data.startsWith("[PARTIAL_ASR]")) {
          const { text } = JSON.parse(data.replace("[PARTIAL_ASR]", ""));
          setActivePartial(text || "");
          return;
        }
        if (data.startsWith("[PARTIAL]")) {
          const { text } = JSON.parse(data.replace("[PARTIAL]", ""));
          setActivePartial(text || "");
          return;
        }
        if (data.startsWith("[FINAL]")) {
          const { text } = JSON.parse(data.replace("[FINAL]", ""));
          setActivePartial(text || "");
          return;
        }
        if (data.startsWith("[DONE]")) {
          const { id, text } = JSON.parse(data.replace("[DONE]", ""));
          clearActivePartial();
          commitFinal(text || "");
          return;
        }
        if (data.startsWith("[UPDATE]")) {
          const { text } = JSON.parse(data.replace("[UPDATE]", ""));
          // Update the last committed line if present
          const last = committed.lastElementChild;
          if (last) last.textContent = (text || "").trim();
          return;
        }
        if (data.startsWith("[STREAM]")) {
          setActivePartial(data.replace("[STREAM]", ""));
          return;
        }
      } catch (e) {
        console.warn("Message parse error:", e);
      }
    }

    async function startRecording() {
      try {
        const preferred = [
          "audio/ogg;codecs=opus",
          "audio/webm;codecs=opus",
          "audio/webm"
        ];
        let mimeType = "";
        for (const t of preferred) {
          if (MediaRecorder.isTypeSupported(t)) { mimeType = t; break; }
        }
        if (!mimeType) {
          alert("This browser doesn't support WebM/Opus recording.");
          return;
        }

        mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });

        socket = new WebSocket(wsUrl());
        socket.onopen = () => {
          socket.send(JSON.stringify({ direction: directionSelect.value }));
          recording = true;
          setButtons(true);
          recordLoop(mimeType);
        };
        socket.onmessage = (e) => handleMessage(e.data);
        socket.onclose = () => { setButtons(false); activeDiv = null; };
        socket.onerror = (e) => console.error("WebSocket error:", e);

      } catch (err) {
        console.error("Error starting recording:", err);
        stopRecording();
      }
    }

    async function recordLoop(mimeType) {
      while (recording) {
        const recorder = new MediaRecorder(mediaStream, { mimeType });

        recorder.ondataavailable = async (e) => {
          if (e.data.size > 0 && socket?.readyState === WebSocket.OPEN) {
            try {
              const buf = await e.data.arrayBuffer();
              socket.send(buf);
            } catch (err) {
              console.warn("send buffer error:", err);
            }
          }
        };

        recorder.start();
        await new Promise((resolve) => {
          setTimeout(() => {
            try { recorder.stop(); } catch {}
            resolve();
          }, 3200); // 3.2s chunks
        });
      }
    }

    function stopRecording() {
      recording = false;
      try { mediaStream?.getTracks().forEach(t => t.stop()); } catch {}
      try { socket && socket.readyState === WebSocket.OPEN && socket.close(); } catch {}
      activeDiv = null;
      setButtons(false);
    }

    startBtn.onclick = startRecording;
    stopBtn.onclick = stopRecording;
  </script>
</body>
</html>
