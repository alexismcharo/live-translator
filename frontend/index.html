<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Socious Translator</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { font-family: 'Inter', 'Helvetica Neue', sans-serif; }
    .caret::after { content: ' ▌'; opacity: 0.6; }
  </style>
</head>
<body class="bg-[#111112] text-white min-h-screen flex flex-col items-center justify-start p-6 space-y-10">

  <h1 class="text-3xl font-bold tracking-tight text-center">Socious Translator</h1>

  <!-- Controls -->
  <div class="w-full max-w-3xl bg-[#1A1A1C] rounded-2xl p-6 shadow-lg flex flex-col items-center space-y-6">
    <div class="w-full flex flex-col lg:flex-row lg:items-end lg:justify-center lg:gap-6 space-y-4 lg:space-y-0">
      <div class="flex flex-col w-full lg:w-auto items-center">
        <label for="direction" class="text-base font-medium mb-1">Translation Direction</label>
        <select id="direction" class="w-full lg:w-64 bg-[#2A2A2E] text-white border border-gray-700 rounded px-4 py-2 focus:outline-none text-center">
          <option value="en-ja">English → Japanese</option>
          <option value="ja-en">Japanese → English</option>
        </select>
      </div>
      <div class="flex flex-col sm:flex-row gap-4">
        <button id="startBtn" class="bg-gray-700 hover:bg-gray-600 text-white font-semibold px-6 py-2 rounded transition-all">Start Recording</button>
        <button id="stopBtn" disabled class="bg-gray-500 text-white font-semibold px-6 py-2 rounded opacity-50 cursor-not-allowed">Stop Recording</button>
      </div>
    </div>
  </div>

  <!-- Output -->
  <div class="w-full max-w-4xl flex flex-col space-y-6 items-center">
    <div class="w-full">
      <div id="output" class="bg-[#1A1A1C] rounded-lg px-6 py-10 shadow-md text-2xl font-semibold leading-8 tracking-wide min-h-[160px] w-full"></div>
    </div>
  </div>

  <script>
    const startBtn = document.getElementById("startBtn");
    const stopBtn = document.getElementById("stopBtn");
    const output = document.getElementById("output");
    const directionSelect = document.getElementById("direction");

    let mediaStream = null;
    let socket = null;
    let recording = false;

    // Single rolling paragraph + ordered segments
    const segmentOrder = [];          // [id1, id2, ...]
    const segmentText = new Map();    // id -> text
    let rollingPara = null;

    function wsUrl() {
      const proto = location.protocol === "https:" ? "wss" : "ws";
      return `${proto}://${location.host}/ws`;
    }

    directionSelect.onchange = () => stopRecording();

    function setButtons(running) {
      startBtn.disabled = running;
      stopBtn.disabled = !running;
      startBtn.classList.toggle("opacity-50", running);
      startBtn.classList.toggle("cursor-not-allowed", running);
      stopBtn.classList.toggle("opacity-50", !running);
      stopBtn.classList.toggle("cursor-not-allowed", !running);
    }

    function ensureRollingPara() {
      if (!rollingPara) {
        rollingPara = document.createElement("div");
        rollingPara.className = "paragraph current text-white";
        rollingPara.style.whiteSpace = "normal";
        rollingPara.style.lineHeight = "1.6";
        rollingPara.style.wordBreak = "break-word";
        output.appendChild(rollingPara);
      }
      return rollingPara;
    }

    function rebuildParagraph() {
      const p = ensureRollingPara();
      const pieces = segmentOrder.map(id => segmentText.get(id)).filter(Boolean);
      p.textContent = pieces.join(" ");
      // trim to a rolling window
      const maxChars = 800;
      if (p.textContent.length > maxChars) {
        while (p.textContent.length > maxChars && segmentOrder.length > 1) {
          const removed = segmentOrder.shift();
          segmentText.delete(removed);
        }
        p.textContent = segmentOrder.map(id => segmentText.get(id)).filter(Boolean).join(" ");
      }
    }

    function setActivePartial(text) {
      let ghost = document.getElementById("ghost-partial");
      if (!ghost) {
        ghost = document.createElement("span");
        ghost.id = "ghost-partial";
        ghost.className = "text-gray-300 italic caret";
        ensureRollingPara().appendChild(document.createTextNode(" "));
        ensureRollingPara().appendChild(ghost);
      }
      ghost.textContent = text;
    }
    function clearActivePartial() {
      const ghost = document.getElementById("ghost-partial");
      if (ghost?.parentNode) ghost.parentNode.removeChild(ghost);
    }
    function setAsrPartial(text) { setActivePartial(text); }
    function clearAsrPartial() { /* cleared with active partial */ }

    function handleMessage(data) {
      try {
        if (data.startsWith("[PARTIAL_ASR]")) {
          const { text } = JSON.parse(data.replace("[PARTIAL_ASR]", ""));
          setAsrPartial(text || "");
          return;
        }
        if (data.startsWith("[PARTIAL]")) {
          const { text } = JSON.parse(data.replace("[PARTIAL]", ""));
          setActivePartial(text || "");
          return;
        }
        if (data.startsWith("[FINAL]")) {
          const { text } = JSON.parse(data.replace("[FINAL]", ""));
          setActivePartial(text || "");
          return;
        }
        if (data.startsWith("[DONE]")) {
          const { id, text } = JSON.parse(data.replace("[DONE]", ""));
          clearActivePartial();
          if (id && text) {
            if (!segmentText.has(id)) segmentOrder.push(id);
            segmentText.set(id, text);
            rebuildParagraph();
          } else if (text) {
            const tempId = `temp-${Date.now()}`;
            segmentOrder.push(tempId);
            segmentText.set(tempId, text);
            rebuildParagraph();
          }
          return;
        }
        if (data.startsWith("[UPDATE]")) {
          const { id, text } = JSON.parse(data.replace("[UPDATE]", ""));
          if (id) {
            if (!segmentText.has(id)) segmentOrder.push(id);
            segmentText.set(id, text || "");
            rebuildParagraph();
          }
          return;
        }
        if (data.startsWith("[STREAM]")) {
          setActivePartial(data.replace("[STREAM]", ""));
          return;
        }
      } catch (e) {
        console.warn("Message parse error:", e);
      }
    }

    async function startRecording() {
      try {
        const preferred = [
          "audio/ogg;codecs=opus",
          "audio/webm;codecs=opus",
          "audio/webm"
        ];
        let mimeType = "";
        for (const t of preferred) {
          if (MediaRecorder.isTypeSupported(t)) { mimeType = t; break; }
        }
        if (!mimeType) {
          alert("This browser doesn't support WebM/Opus recording.");
          return;
        }

        mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });

        socket = new WebSocket(wsUrl());
        socket.onopen = () => {
          socket.send(JSON.stringify({ direction: directionSelect.value }));
          recording = true;
          setButtons(true);
          recordLoop(mimeType);   // 3.2s chunk loop
        };
        socket.onmessage = (e) => handleMessage(e.data);
        socket.onclose = () => { clearActivePartial(); clearAsrPartial(); setButtons(false); };
        socket.onerror = (e) => console.error("WebSocket error:", e);

      } catch (err) {
        console.error("Error starting recording:", err);
        stopRecording();
      }
    }

    async function recordLoop(mimeType) {
      while (recording) {
        const recorder = new MediaRecorder(mediaStream, { mimeType });

        recorder.ondataavailable = async (e) => {
          if (e.data.size > 0 && socket?.readyState === WebSocket.OPEN) {
            try {
              const buf = await e.data.arrayBuffer();
              socket.send(buf);
            } catch (err) {
              console.warn("send buffer error:", err);
            }
          }
        };

        recorder.start();   // manual duration
        await new Promise((resolve) => {
          setTimeout(() => {
            try { recorder.stop(); } catch {}
            resolve();
          }, 3200);         // 3.2s chunks
        });
      }
    }

    function stopRecording() {
      recording = false;
      try { mediaStream?.getTracks().forEach(t => t.stop()); } catch {}
      try { socket && socket.readyState === WebSocket.OPEN && socket.close(); } catch {}
      clearActivePartial(); clearAsrPartial(); setButtons(false);
    }

    startBtn.onclick = startRecording;
    stopBtn.onclick = stopRecording;
  </script>
</body>
</html>
