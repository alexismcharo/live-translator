<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Socious Translator</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      font-family: 'Inter', 'Helvetica Neue', sans-serif;
    }
  </style>
</head>
<body class="bg-[#111112] text-white min-h-screen flex flex-col items-center justify-center p-6 space-y-10">
  <h1 class="text-5xl font-bold tracking-tight text-center">Socious Translator</h1>

  <div class="w-full max-w-2xl bg-[#1A1A1C] rounded-lg p-6 shadow-lg space-y-6 flex flex-col items-center">
    <label class="block text-base font-medium">Translation Direction</label>
    <select id="direction" class="w-full max-w-md bg-[#2A2A2E] text-white border border-gray-700 rounded px-4 py-2 focus:outline-none text-center">
      <option value="en-ja">English → Japanese</option>
      <option value="ja-en">Japanese → English</option>
    </select>

    <div class="flex gap-4 mt-4">
      <button id="startBtn" class="bg-gray-700 hover:bg-gray-600 text-white font-semibold px-6 py-2 rounded transition-all">Start Recording</button>
      <button id="stopBtn" disabled class="bg-gray-500 text-white font-semibold px-6 py-2 rounded opacity-50 cursor-not-allowed">Stop Recording</button>
    </div>
  </div>

  <div id="output" class="w-full max-w-6xl bg-[#1A1A1C] rounded-lg px-10 py-20 shadow-xl text-2xl font-semibold text-center leading-tight tracking-wide min-h-[320px] flex flex-col justify-end space-y-6"></div>

  <script>
    const startBtn = document.getElementById("startBtn");
    const stopBtn = document.getElementById("stopBtn");
    const output = document.getElementById("output");
    const directionSelect = document.getElementById("direction");

    let stream = null;
    let socket = null;
    let recording = false;
    let activeLine = null;

    directionSelect.onchange = () => stopRecording();

    async function startRecording() {
      try {
        stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        socket = new WebSocket("ws://34.69.242.211:8000/ws");

        socket.onopen = () => {
          socket.send(JSON.stringify({ direction: directionSelect.value }));
          recording = true;
          recordLoop();

          startBtn.disabled = true;
          stopBtn.disabled = false;
          startBtn.classList.add("opacity-50", "cursor-not-allowed");
          stopBtn.classList.remove("opacity-50", "cursor-not-allowed");
        };

        socket.onmessage = (event) => {
          const data = event.data;

          // Make sure we have a paragraph block for finalized content
          let paragraphDiv = output.querySelector(".paragraph");
          if (!paragraphDiv) {
            paragraphDiv = document.createElement("div");
            paragraphDiv.className = "paragraph text-white";
            paragraphDiv.dataset.final = "true";
            output.appendChild(paragraphDiv);
          }

          if (data.startsWith("[STREAM]")) {
            const text = data.replace("[STREAM]", "");

            if (!activeLine) {
              activeLine = document.createElement("div");
              activeLine.className = "text-gray-300 italic";
              output.appendChild(activeLine);
            }

            requestAnimationFrame(() => {
              activeLine.textContent = text + " ▌";
            });
          }

          else if (data.startsWith("[DONE]")) {
            const finalText = data.replace("[DONE]", "").trim();
            if (finalText && paragraphDiv) {
              requestAnimationFrame(() => {
                // Append finalized text to the paragraph
                paragraphDiv.textContent += (paragraphDiv.textContent.endsWith(" ") ? "" : " ") + finalText;

                // Trim words from start if total exceeds character limit
                const maxChars = 350;
                if (paragraphDiv.textContent.length > maxChars) {
                  const words = paragraphDiv.textContent.trim().split(" ");
                  while (paragraphDiv.textContent.length > maxChars && words.length > 1) {
                    words.shift(); // remove oldest word
                    paragraphDiv.textContent = words.join(" ");
                  }
                }

                // Clean up the active line
                if (activeLine) {
                  output.removeChild(activeLine);
                  activeLine = null;
                }
              });
            }
          }
        };
      } catch (err) {
        console.error("Error:", err);
      }
    }

    async function recordLoop() {
      while (recording) {
        const mimeType = "audio/webm";
        const recorder = new MediaRecorder(stream, { mimeType });

        recorder.ondataavailable = async (e) => {
          if (e.data.size > 0 && socket?.readyState === WebSocket.OPEN) {
            const buffer = await e.data.arrayBuffer();
            socket.send(buffer);
          }
        };

        recorder.start();
        await new Promise((resolve) => {
          setTimeout(() => {
            recorder.stop();
            resolve();
          }, 2500);
        });
      }
    }

    function stopRecording() {
      recording = false;
      if (stream) stream.getTracks().forEach((t) => t.stop());
      if (socket && socket.readyState === WebSocket.OPEN) socket.close();

      startBtn.disabled = false;
      stopBtn.disabled = true;
      startBtn.classList.remove("opacity-50", "cursor-not-allowed");
      stopBtn.classList.add("opacity-50", "cursor-not-allowed");
    }

    startBtn.onclick = startRecording;
    stopBtn.onclick = stopRecording;
  </script>
</body>
</html>
